<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/solarized.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1 class="r-fit-text">From Legacy to Modern</h1>
          <h3 class="r-fit-text">
            Our Experience Migrating a Complex Application with Microfrontends
          </h3>
          <p style="font-size: 2rem">
            John Oerter
            <br />
            <a href="https://x.com/joerter10">@joerter10</a> |
            <a href="https://johnoerter.me">johnoerter.me</a>
            <br />
            Lead Software Engineer at Dina
            <br />
            <a href="https://microfrontends.johnoerter.me"
              >microfrontends.johnoerter.me</a
            >
          </p>
          <aside class="notes">
            <ul>
              <li>Introduce myself</li>
              <li>
                This is essentially a case study in how we used microfrontends
                to migrate away from a legacy app in AngularJS to React
              </li>
              <li>
                Even though the specific tech may not be fully applicable to you
                or your company, my hope is that something will be inspiring or
                help you solve your own problems
              </li>
              <li>
                Feel free to ask questions during the talk, I want this to be
                interactive
              </li>
              <li>Follow along if you'd like</li>
            </ul>
          </aside>
        </section>
        <section data-auto-animate>
          <h1 class="r-fit-text">September 14, 2016</h1>
          <aside class="notes">
            <ul>
              <li>This is like when a movie opens with a flashback</li>
              <li>
                Raise your hand if you were developing software in September
                2016. Just for my own curiosity
              </li>
              <li>
                Does anyone know a significant event that happened on this date?
                Hint: it's in the front end dev world
              </li>
            </ul>
          </aside>
        </section>
        <section data-auto-animate>
          <h1 class="r-fit-text">September 14, 2016</h1>
          <img src="/images/angular-logo.svg" />
          <aside class="notes">
            <ul>
              <li>
                Angular was announced a couple years prior, but this is when it
                was first available
              </li>
              <li>
                A very confusing time. I still don't know why they chose the
                name Angular and not something completely different
              </li>
              <li>This was the height of JS fatigue</li>
            </ul>
          </aside>
        </section>
        <section>
          <div class="r-stack">
            <img class="fragment" src="/images/angularjs-logo.png" />
            <div
              class="fragment"
              style="
                font-family: Arial, sans-serif;
                font-size: 48px;
                font-weight: bold;
                color: red;
                border: 4px solid red;
                display: inline-block;
                padding: 10px 20px;
                transform: rotate(-15deg);
                letter-spacing: 5px;
                text-shadow: 2px 2px 0 rgba(255, 0, 0, 0.3);
                box-shadow:
                  0 0 0 3px red inset,
                  2px 2px 10px rgba(0, 0, 0, 0.3);
                background: rgba(255, 255, 255, 1);
              "
            >
              LEGACY
            </div>
          </div>
          <aside class="notes">
            <ul>
              <li>
                What did that mean for all the beautiful AngularJS apps out
                there? They are now legacy.
              </li>
              <li>
                AngularJS would continue to receive some updates but cease being
                officially supported at the end of 2021
              </li>
              <li>
                Again for my curiosity, raise your hand if you were supporting
                or building an AngularJS app during this time.
              </li>
              <li>
                Where I was working at the time I had a sweet setup with
                Browserify and Gulp to build my AngularJS app and I really
                enjoyed it
              </li>
              <li>Migrating off of legacy software is really hard</li>
              <li>
                TRANSITION: This is where we were at when I joined Dina in 2022.
              </li>
              <li>
                This talk is specifically about a success story in migrating
                from AngularJS to React using microfrontends
              </li>
              <li>
                However, I hope that even if that isn't your specific situation,
                you can glean some inspiration and ideas from this talk to apply
                to your own work
              </li>
            </ul>
          </aside>
        </section>
        <section data-visibility="hidden">
          <h1 class="r-fit-text">Migrating off legacy technology is hard.</h1>
        </section>
        <section data-visibility="hidden">
          <h3>The Problem</h3>
          <ul>
            <li>No new features, bug fixes, or security updates</li>
            <li>Skill stagnation, missing out on career growth, frustration</li>
          </ul>
          <aside class="notes">
            <ul>
              <li>
                When I joined Dina in 2022, our flagship app was in AngularJS
              </li>
              <li>
                These problems should be obvious, but we'll go through them
              </li>
              <li>Can't take advantage of new browser features</li>
              <li>Supporting libraries are usually abandoned</li>
              <li>
                Again, you can apply this to any technology stack, not just
                AngularJS and front-end
              </li>
            </ul>
          </aside>
        </section>
        <section>
          <img src="/images/uxdownstreamdx.svg" alt="" />
          <aside class="notes">
            <ul>
              <li>
                Why is using a legacy technology so detrimental to your product?
              </li>
	      <li>UX is downstream of DX</li>
              <li>
                This is something I've believed for a long time and why DX is so
                important to me
              </li>
              <li>
                We as developers are craftsman, and if our tools are old, dull,
                and rusty - how can we create beautiful products?
              </li>
              <li>
                What I mean by this is, if your development process sucks, the
                quality of your product will suffer
              </li>
              <li>
                The frustration, slow build times, hunting around for bugs in
                abandoned libraries all takes mental power away from innovation,
                and really caring about the quality of the product, because as a
                developer, I'm just fighting getting basic things to work
                consistently
              </li>
              <li>
                A frustrated engineer will create a product that frustrates
                users
              </li>
            </ul>
          </aside>
        </section>
        <section>
          <h1 class="r-fit-text fragment">How do you fix this?</h1>
          <h2 class="fragment fade-in">Full rewrite!</h2>
          <aside class="notes">
            <ul>
              <li>The most common solution is... a full rewrite!</li>
              <li>A full rewrite often carries significant issues however</li>
              <li>Quickly go over some more pitfalls of full rewrites</li>
            </ul>
          </aside>
        </section>
        <section data-auto-animate>
          <img src="/images/legacytorewrite.svg" />
          <aside class="notes">
            <ul>
              <li>
                We believe that we can stop working on the old app and begin
                working on the new one
              </li>
            </ul>
          </aside>
        </section>
        <section data-auto-animate>
          <img src="/images/legacytorewrite_bugfixes.svg" />
          <aside class="notes">
            <ul>
              <li>
                In reality, we have to adopt a parallel development strategy
              </li>
              <li>A production system can almost never sit static for long!</li>
              <li>
                There will be bugs that pop up in the legacy app that need to be
                fixed
              </li>
            </ul>
          </aside>
        </section>
        <section data-auto-animate>
          <img src="/images/legacytorewrite_features.svg" />
          <aside class="notes">
            <ul>
              <li>
                We will inevitably have high priority features that need to be
                delivered NOW!
              </li>
              <li>
                We have to make the update in both places, which costs double in
                all facets: pm, testing, build, deployment
              </li>
            </ul>
          </aside>
        </section>
        <section data-auto-animate>
          <img src="/images/schism.svg" />
          <aside class="notes">
            <li>Who will work on the new app vs old?</li>
            <li>
              Often times, the senior engineers and architects build the new
              version while the juniors are left to maintain the old.
            </li>
            <li>Make sense to some degree. Forging new paths is tricky work</li>
            <li>
              Leads to context switching for the senior engineers to help out
              with questions or prod issues on the legacy system
            </li>
            <li>
              Leads to alienation for the junior engineers. Who wants to be
              stuck maintaining a legacy app? Is there anything more fun or
              exciting as an engineer than a greenfield project?
            </li>
          </aside>
        </section>
        <section data-auto-animate>
          <img src="/images/newteam.svg" />
          <aside class="notes">
            <li>Let's hire a new team</li>
            <li>
              Consultants or new hires are missing key domain knowledge and
              experience
            </li>
            <li>
              More alienation for experienced engineers working on the old
              system
            </li>
          </aside>
        </section>
        <section data-auto-animate>
          <img src="/images/featureparity1.svg" />
          <aside class="notes">
            <ul>
              <li>
                The goal of feature parity becomes a moving goal post for a
                couple reasons:
              </li>
              <li>
                Unknown unknowns
                <ul>
                  <li>
                    We try to estimate how long the rewrite will take, but we
                    are certainly wrong
                  </li>
                  <li>
                    These unkonw unknowns are like landmines lurking out there
                    waiting to blow up the rewrite effort
                  </li>
                  <li>
                    Makes the goal of feature parity seem like a moving goal
                    post and always "just out of reach"
                  </li>
                  <li>
                    Lowers morale on the team, and causes mistrust in the
                    business. People start talking about this rewrite that has
                    been promised for a long time when all our problems will be
                    solved. It never comes
                  </li>
                </ul>
              </li>
              <li>
                The Second System Effect
                <ul>
                  <li>From the Mythical Man-Month by Fred Brooks</li>
                  <li>
                    The tendency for the rewrite to become an over-engineered
                    mess due to inflated expectations and overconfidence
                  </li>
                  <li>
                    We try to get rid of all tech debt in one shot with the
                    rewrite
                  </li>
                  <li>
                    We tend to let scope creep take over and continue to rewrite
                    other parts of the system that weren't initially on the
                    table
                  </li>
                  <li>
                    "Why not break our back end into microservices while we're
                    at it!"
                  </li>
                  <li>Engineers aren't the only ones guilty of this:</li>
                  <li>
                    Let's add this one feature customers have been dying for
                    while we're at it!
                  </li>
                </ul>
              </li>
              <li>
                Overcorrection
                <ul>
                  <li>
                    Since we got burned by the fast moving front-end JS world,
                    let's build on a solid, old school backend framework like
                    .NET, Rails, etc.
                  </li>
                </ul>
              </li>
            </ul>
          </aside>
        </section>
        <section data-auto-animate>
          <img src="/images/bigbangrelease.svg" />
          <aside class="notes">
            <ul>
              <li>
                At some point, if you're lucky, you finally reach parity and can
                release. Most rewrites won't even make it that far
              </li>
              <li>Often, you have to "cutover" to the new app all at once</li>
              <li>
                Rewrites aren't generally condusive to the MVP / Agile
                methodology of getting early feedback from users
              </li>
              <li>
                Puts a lot of pressure on the team since they don't have
                anything tangible until it's 100% ready
              </li>
              <li>
                inevitably leads to more distrust and contempt from the business
                as they try to wait patiently
              </li>
            </ul>
          </aside>
        </section>
        <section>
          <h1 class="r-fit-text">Pitfalls of Rewrites</h1>
          <ul>
            <li>Double the Work, Double the Cost</li>
            <li>Lower Team Morale</li>
            <li>Unknown Unknowns</li>
            <li>The Second System Effect</li>
            <li>"Big Bang" Release</li>
          </ul>
          <p style="font-size: 1rem">
            <strong>Further Reading</strong>
            <br />
            <a
              href="https://www.bennorthrop.com/rewrite-or-refactor-book/chapter-2-the-risks-of-rewrites.php"
              >The Risk Of Rewrites</a
            >
            - Ben Northrop
            <br />
            <a
              href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/"
              >Things You Should Never Do</a
            >
            - Joel Spolsky
          </p>
          <aside class="notes">
            <ul>
              <li>Parallel development is inevitable</li>
              <li>Someone has to be left behind working on the old system</li>
              <li>There's always unknowns that pop up to derail the effort</li>
              <li>
                The rewrite is actually more than likely to have it's own worts
                and be overengineered
              </li>
              <li>
                Big bang release is risky, and will probably dissapoint users
                who haven't had a chance to give feedback
              </li>
            </ul>

            <h2>
              Before I go on, does this resonate with anyone? This is your
              chance to tell your war stories
            </h2>
          </aside>
        </section>
        <section data-auto-animate>
          <h1 class="r-fit-text">Microfrontends</h1>
          <div>
            <q
              >An architectural style where independently deliverable frontend
              applications are composed into a greater whole</q
            >
            -
            <a href="https://martinfowler.com/articles/micro-frontends.html"
              >Martin Fowler and Thoughtworks</a
            >
          </div>
          <aside class="notes">
            <ul>
              <li>
                We chose to solve this problem using microfrontends instead
              </li>
              <li>
                Arrived on Technology Radar in 2016 and quickly moved into the
                "Adopt" category, meaning it's a proven approach. Hold, Assess,
                Trial, Adopt
              </li>
              <li>What does "composed into a greater whole" mean exactly?</li>
              <li>
                For us, it meant we needed to make these separate frontends
                appear to be part of the same web application to the user
              </li>
              <li>They should be served on the same domain</li>
            </ul>
          </aside>
        </section>
        <section data-auto-animate>
          <h1 class="r-fit-text">Microfrontends</h1>
          <img src="/images/microfrontendscomposition.png" alt="" />
          <aside class="notes">
            <ul>
              <li>Benefits are very similar to those of microservices</li>
              <li>
                smaller codebases:
                <ul>
                  <li>
                    easier to draw thicker lines around bounded contexts of the
                    application. For example, sharing domain models between
                    bounded contexts is harder and coupling is less likely to
                    happen. The pit of success is bigger
                  </li>
                </ul>
              </li>
              <li>
                scalable organizations
                <ul>
                  <li>
                    ability for autonomous teams to own a domain from end to end
                  </li>
                  <li>
                    Key point! We can organize teams around domains instead of
                    technical capability!
                  </li>
                </ul>
              </li>
              <li>
                rewrite
                <ul>
                  <li>
                    unlocks the strangler fig pattern to slowly replacing pieces
                    of the legacy application
                  </li>
                  <li>
                    We can release these smaller pieces to production as they
                    are ready, and get immediate feedback
                  </li>
                  <li>
                    Most, if not all of the rewrite pitfalls are immediately
                    mitigated!
                  </li>
                </ul>
              </li>
              <li>This is the way microfrontends are commonly composed</li>
            </ul>
          </aside>
        </section>
        <section data-auto-animate>
          <img src="/images/monolith.svg" alt="" />
          <aside class="notes">
            <ul>
              <li>
                There are an infinite number of ways to implement
                microfrontends. I'm going to show you how we did it
              </li>
            </ul>
          </aside>
        </section>
        <section data-auto-animate>
          <img src="/images/login-pullout.svg" alt="" />
        </section>
        <section data-auto-animate>
          <img src="/images/microsites.svg" alt="" />
          <aside class="notes">
            <ul>
              <li>
                There are an infinite number of ways to implement
                microfrontends. I'm going to show you how we did it
              </li>
            </ul>
          </aside>
        </section>
        <section>
          <img src="/images/cloudfront.svg" alt="" />
        </section>
        <section data-auto-animate>
          <img src="/images/inbox-example.svg" alt="" />
        </section>
        <section data-auto-animate>
          <img src="/images/inbox-example2.svg" alt="" />
        </section>
        <section>
          <pre>
		<code class="language-bash" data-trim data-noescape>
app.dinacare.com/
├── apps/
│   ├── auth/
│   ├── inbox/
│   └── reporting/
├── libs/
│   ├── auth/
│   ├── inbox/
│   ├── reporting/
│   └── shared/
└── package.json
		</code>
		</pre>
        </section>
        <section>
          <pre>
		<code class="language-bash" data-trim data-noescape data-line-numbers="2-5|6-10">
app.dinacare.com/
├── apps/
│   ├── auth/
│   ├── inbox/
│   └── reporting/
├── libs/
│   ├── auth/
│   ├── inbox/
│   ├── reporting/
│   └── shared/
└── package.json
		</code>
		</pre>
        </section>
        <section>
          <pre>
		<code data-trim data-noescape class="language-bash" data-line-numbers="3-6|11-15">
app.dinacare.com/
├── apps/
│   ├── auth/
│   │   ├── main.tsx
│   │   ├── router.tsx
│   │   └── index.html
│   ├── inbox/
│   └── reporting/
├── libs/
│   ├── auth/
│   ├── inbox/
│   │   ├── feature/
│   │   │   └── new-referral/
│   │   └── shared/
│   │       └── components/
│   ├── reporting/
│   └── shared/
└── package.json
		</code>
		</pre>
        </section>
        <section>
          <img src="/images/nx-graph.svg" alt="" />
        </section>
        <section>
          <img src="/images/johnbug.svg" alt="" />
        </section>
        <section>
          <img src="/images/local-dev.svg" alt="" />
        </section>
        <section>
          <img src="/images/pr-changeset.svg" alt="" />
        </section>
        <section>
          <img src="/images/build-release.svg" alt="" />
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
